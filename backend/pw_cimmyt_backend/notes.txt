# control

    @gen.coroutine
    def push(self, label='PUSH', **kwargs):
        data = dict(node_id=self.node_id, label=label, node=self.node_info)
        data.update(kwargs)
        if 'callback' in data:
            del data['callback']
        data = jsondumps(data)
        response = yield gen.Task(self.publisher.publish, _CHANNEL, data)
        raise gen.Return(response)

    @gen.coroutine
    def register(self, **kwargs):
        response = yield gen\
            .Task(self.publisher.set, self.node_id, self.node_info)
        logging.debug(' * Registered: %s', response)
        raise gen.Return(response)

    @gen.coroutine
    def unregister(self, **kwargs):
        response = yield gen \
            .Task(self.publisher.delete, self.node_id)
        logging.debug(' * Unregistered: %s', response)
        raise gen.Return(response)

    @gen.coroutine
    def _on_message(self, message):
        if message.kind == 'message':
            _body, body = strucloads(message.body)
            if body.node_id != self.node_id:
                if body.label in ('SUBSCRIBE', 'CHANGE'):
                    value = yield gen.Task(self.publisher.get, body.node_id)
                    self.nodes[body.node_id] = jsonloads(value)
                elif body.label == 'UNSUBSCRIBE' and body.node_id in self.nodes:
                    del self.nodes[body.node_id]
                logging.warn('(%s) %s', body.label, body.node_id)
            if len(self.nodes) < 1:
                self._stop_pull()
            elif len(self.nodes) > 0:
                self._start_pull()

    def _start_pull(self, force=False):
        if not self.pull.is_running() or force is True:
            self.pull.start()
            logging.debug(' * Pull task started...')

    def _stop_pull(self, force=False):
        if self.pull.is_running() or force is True:
            self.pull.stop()
            logging.debug(' * Pull task stopped...')

    @gen.coroutine
    def _on_pull(self, **kwargs):
        global _PULL_COUNTER
        self._stop_pull()
        check_times = self.settings['pull_check_times']
        try:
            if _PULL_COUNTER is None or _PULL_COUNTER >= check_times:
                if self.publisher.connection.connected():
                    yield self._on_pull_nodes()
                else:
                    logging.error(' ! Check connection refused')
                    if self.RECONNECTING in (None, False):
                        self.try_reconnect()
                _PULL_COUNTER = 0
                logging.debug(' * Check reset')
        except Exception, e:
            logging.error(' ! Check reset error', exc_info=e)
        try:
            for node, value in self.nodes.iteritems():
                value = Struct(value)
                url = 'http://{ip}:{port}/ping'\
                    .format(ip=value.ip, port=value.port)
                response = yield _fetch(url)
                if isinstance(response, httpclient.HTTPResponse):
                    logging.error(' ! Fetch ~ %s :: %s', node, response.error)
                    if node not in self.fallen_nodes:
                        self.fallen_nodes.add(node)
                else:
                    logging.debug(' * Fetch ~ %s :: %s',
                                 node, response.get('response'))
                    if node in self.fallen_nodes:
                        self.fallen_nodes.remove(node)
        except Exception, e:
            logging.error(' ! Fetch error', exc_info=e)
        _PULL_COUNTER += 1
        check = len(self.nodes)
        fallen = len(self.fallen_nodes)
        logging.debug(' * Check %s of %s nodes', check - fallen, check)
        logging.debug(' * Fallen %s of %s nodes', fallen, check)
        logging.debug(' * Pull %s of %s to reset', _PULL_COUNTER,
                      check_times)
        self._start_pull()
        raise gen.Return(True)

    @gen.coroutine
    def _on_pull_nodes(self, **kwargs):
        global _NODES, _FALLEN_NODES
        _NODES = {}
        _FALLEN_NODES = set()
        nodes = yield gen.Task(self.publisher.keys, 'node:*')
        for node in nodes:
            value = yield gen.Task(self.publisher.get, node)
            _data, data = strucloads(value)
            node_id = _NODE.format(ip=data.ip, port=data.port)
            if node_id != self.node_id:
                self.nodes[node_id] = _data
        logging.debug(' * Recovered nodes:')
        logging.debug(' ~ Not found' if not self.nodes
                      else jsondumps(self.nodes, indent=2))

    @gen.coroutine
    def _connect_publisher(self, **kwargs):
        global _PUBLISHER
        config = self.settings.get('keyvalues', {})[_CHANNEL]['config']
        logging.debug(' * Starting publisher...')
        _publisher = memory.get_client(config, async=True)
        try:
            _publisher.connect()
            _PUBLISHER = _publisher
            response = True
        except:
            response = False
        raise gen.Return(response)

    @gen.coroutine
    def _connect_mission_control(self, **kwargs):
        global _MISSION_CONTROL
        config = self.settings.get('keyvalues', {})[_CHANNEL]['config']
        logging.debug(' * Starting mission control...')
        _mission_control = memory.get_client(config, async=True)
        try:
            _mission_control.connect()
            yield gen.Task(_mission_control.subscribe, _CHANNEL)
            _mission_control.listen(self._on_message)
            _MISSION_CONTROL = _mission_control
            response = True
        except:
            response = False
        raise gen.Return(response)

    @gen.coroutine
    def reconnect(self, **kwargs):
        response = False
        conn = yield self._connect_publisher()
        if conn is True:
            register = yield self.register()
            if register is True:
                yield self._on_pull_nodes()
                conn = yield self._connect_mission_control()
                if conn is True:
                    yield self.push('SUBSCRIBE')
                    response = True
                else:
                    logging.error(' ! Node "%s" could not be subscribed',
                                  self.node_id)
            else:
                logging.error(' ! Node "%s" could not be registered',
                              self.node_id)
        else:
            logging.error(' ! Node "%s" could not be connected',
                          self.node_id)
        raise gen.Return(response)

    @gen.coroutine
    def try_reconnect(self, **kwargs):
        loop = ioloop.IOLoop.current()
        logging.error(' * Try reconnect...')
        try:
            loop.remove_timeout(self.try_reconnect)
            response = yield self.reconnect()
            if response is False:
                raise RuntimeError, 'Try reconnect...'
            self.RECONNECTING = True
        except:
            self.RECONNECTING = False
            loop.add_timeout(self.settings['pull_reconnect_time'],
                             self.try_reconnect)

    def _stop_try_reconnect(self):
        loop = ioloop.IOLoop.current()
        loop.remove_timeout(self.try_reconnect)
        self.RECONNECTING = True

    @gen.coroutine
    def start(self, **kwargs):
        global _PULL
        response = yield self.reconnect()
        if response is True:
            pull = ioloop \
                .PeriodicCallback(self._on_pull, self.settings['pull_time'])
            _PULL = pull
        raise gen.Return(response)

    @gen.coroutine
    def _disconnect_publisher(self, **kwargs):
        global _PUBLISHER
        logging.debug(' * Stopping publisher...')
        if self.publisher is not None:
            yield gen.Task(self.publisher.disconnect)
        _PUBLISHER = None
        raise gen.Return()

    @gen.coroutine
    def _disconnect_mission_control(self, **kwargs):
        global _MISSION_CONTROL
        logging.debug(' * Stopping mission control...')
        if self.mission_control is not None:
            yield gen.Task(self.mission_control.unsubscribe, _CHANNEL)
            yield gen.Task(self.mission_control.disconnect)
            yield self.unregister()
            yield self.push('UNSUBSCRIBE')
        _MISSION_CONTROL = None
        raise gen.Return()

    @gen.coroutine
    def shutdown(self, **kwargs):
        global _CLIENTS, _NODES, _FALLEN_NODES, _PULL, _PULL_COUNTER
        self._stop_pull()
        _PULL = None
        _PULL_COUNTER = None
        self._stop_try_reconnect()
        logging.debug(' * Closing all clients...')
        for client in self.clients:
            if client.ws_connection:
                try:
                    client.close()
                except:
                    pass
            self.clients.remove(client)
        _CLIENTS = None
        yield self._disconnect_mission_control()
        yield self._disconnect_publisher()
        _NODES = None
        _FALLEN_NODES = None
        raise gen.Return()